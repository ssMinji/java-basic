package org.tutorials.javatutorials.interfaces;

class E{
    public String x(){return "x";}
    
    // step 2
    //public String x(){return "E.x";}
}
class F extends E{
    public String y(){return "y";}
    
    // step 2
    //public String x(){return "F.x";}
}
public class PolymorphismDemo1 {
    public static void main(String[] args) {
    	// 클래스 F로 객체를 생성하는데 이때의 데이터타입이 E입니다. 
    	// F를 살펴보면 E를 상속받고 있지요. 
    	// 클래스 F로 인스턴스를 만들었지만 이는 클래스 E의 데이터타입의 행세를 하고있는것입니다

    	// 이렇게 하는 이유에 대해서 설명해보도록할게요 
    	E obj = new F();
        obj.x();
        obj.y();
        // 에러 
        // x는 클래스F의 부모클래스인 E클래스에 존재하고 있죠 
        // obj는 B를 인스턴스화시키고 있지만 클래스 A의 행세를 하고 있기 때문에
        // x를 호출하는 것은 정상적으로 동작하지만
        // y를 호출하는 것은 불가능하다 
        // obj가 행세하고 있는 클래스 E안에는 y가 존재하지 않기 때문이다 
        // 즉, obj의 데이터타입은 E이기 때문에 에러가 나는 것이다 
        // 결론
        // 어떠한 클래스를 인스턴스화시킬 때 인스턴스를 담는 변수의 데이터 타입은
        // 해당 클래스가 될 수도 있고, 그 클래스의 부모클래스가 될 수도 있다. 
        // 이 인스턴스가 마치 부모클래스인 E인것처럼 동작할 수 있다는 것이고,
        // E클래스에는 y가 없기 때문에 이는 호출할 수 없다
        // 왜 쓰는지가 중요하다 
        
        // step2 코드를 쳐보자
        // F의 x는 E의 x메소드를 오버라이딩 하고 있다 
        // 그럼 F의 x메소드의 우선순위가 더 높다 
        // 이 때 E obj = new F();하고 obj.x(); 출력해보면
        // 원래클래스는 F지만 E 행세를 하고있는 obj내에 있는 x를 찍어보면
        // 뭐가 나올까? 
        //결과는 바로 F.x이다. 
        // 이 x라는 메소드는 F의 메소드를 실행하고 있다는 것이다
        // 클래스 E 행세를 하고 있지만 이 메소드 x는 누구의 멤버다? F의 멤버다.
        // 하지만 E행세를 하고있지 때문에 E에 정의되어있지 않은 y메소드는 실행되지 않는다
        
        // 클래스 F에서 추가적으로 정의한 메소드는 실행되지 않는다는 것 
        // 상위클래스의 메소드를 오버라이딩하고있다면 인스턴스화시킨 클래스의 메소드를 실행시킨다는 것
        // 어려우니 차근차근 이해해보자 
    }
}

