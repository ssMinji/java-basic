package abstractEx;

public abstract class Computer {

	//public void display();  // {} 부분이 없으면 구현 하지 않고 선언만 하겠다는 의미 . {}부분을 body 부분이라 함 
	// public void display() {}; : 이렇게 {} 바디를 넣으면 빈 {}라 하더라도 구현부가 있는 것. 
	// 메서드 이름, 매개변수, 반환값 
	// 에러메시지 읽어보기 . 추상메서드로 바꿔라 라는 fix 제안 
	// 즉, 구현부분이 없으면 추상메서드가 됨 
	public abstract void display();
	public abstract void typing();
	// 이번엔 클래스에 에러날 것. 
	// 추상메서드를 가지고 있는 것은 추상클래스 여야 함 - class에 abstract 추가하기 
	
	// 추상메서드
	// 구현해야하는 것은 맞으나 현재 Computer 클래스에서는 어떻게 구현될지 아직 모르는 것 
	// 각각 이를 상속받은 데스크탑이나 노트북에서 어떻게 해야할지를 구체적으로 구현해야 할 때 사용  
	// 이 때, 하위클래스를 '구현에 대한 책임이 있다'라고 얘기
	// 상위클래스에서는 '메서드들의 구현을 하위클래스에 위임시켰다'라고 함 
	
	public void turnOn() {
		System.out.println("전원을 켭니다.");
	}
	
	public void turnOff() {
		System.out.println("전원을 끕니다.");
	}
	// 추상클래스는 구현된 메서드 또한 가질 수 있음 - 하위클래스에서도 공통으로 사용될 메서드. 물론 오버라이딩 가능 
	
	// 추상클래스는 상속을 하기 위해 만드는 클래스임 
	// 혼자 돌아갈 수없음. 즉, new를 이용해서 인스턴스화 될 수 없음 
	// 추상클래스를 바탕으로 이 추상클래스에 기반한 하위클래스를 구현하게 됨  
	
	//public abstract int add(int x, int y);// 메서드 이름, 매개변수, 반환값타입 을 보면 이 메서드가 뭐하는 메서드인지 유추 가능 
	// 즉 선언만 하더라도 기능의 절반은 구현했다고 볼 수 있음 
	// 실제 기능 구현은 하위클래스에서 하게 됨 
}
